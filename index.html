<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>哈利·波特与怪奇物语：施法粒子</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #0a0a0d, #000); /* 更深的背景 */
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      color: #fff;
    }

    /* 模拟颠倒世界的微弱动态背景 */
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 100 100"><filter id="n" x="0" y="0" width="100%" height="100%"><feTurbulence type="fractalNoise" baseFrequency="0.005" numOctaves="1" result="f"></feTurbulence><feColorMatrix type="matrix" values="0 0 0 0 0, 0 0 0 0 0, 0 0 0 0 0, 0 0 0 0.1 0"></feColorMatrix></filter><rect width="100%" height="100%" filter="url(%23n)"></rect></svg>');
      opacity: 0.1; /* 微弱效果 */
      animation: noise-anim 10s infinite alternate linear;
      pointer-events: none;
    }

    @keyframes noise-anim {
      0% { transform: translate(0, 0); }
      100% { transform: translate(100%, 100%); }
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
      background: rgba(20, 25, 40, 0.7);
      backdrop-filter: blur(10px);
      border-radius: 14px;
      padding: 12px 14px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    select, input, button {
      background: #1e2438;
      border: 1px solid #3a3f5a;
      color: white;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 13px;
    }

    #fullscreenBtn {
      position: fixed;
      left: 20px;
      top: 90px;
      z-index: 10;
    }

    #tip {
      position: fixed;
      bottom: 20px;
      width: 100%;
      text-align: center;
      font-size: 13px;
      opacity: 0.7;
    }
    
    #tip span {
        display: block;
        margin-top: 5px;
        font-size: 11px;
        color: #aaa;
    }

    canvas {
      display: block;
    }

    #startBtn {
      position: fixed;
      inset: 0;
      margin: auto;
      width: 170px;
      height: 54px;
      font-size: 17px;
      border-radius: 14px;
      border: none;
      background: linear-gradient(135deg,#6ea8ff,#4760ff);
      color: white;
      z-index: 9999;
    }

    video {
      display: none;
    }

    #spellText {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4em;
      font-weight: bold;
      color: #ffd700; /* 金色 */
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 10px rgba(255, 215, 0, 0.5);
      opacity: 0;
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
      pointer-events: none;
      z-index: 11;
      white-space: nowrap; /* 防止换行 */
    }
    .spell-active {
        opacity: 1 !important;
        transform: translate(-50%, -50%) scale(1.1);
    }
  </style>
</head>

<body>

<button id="startBtn">开始体验</button>

<div id="ui">
  <select id="shapeSelect">
    <option value="default">默认星云</option>
    <option value="heart">爱心</option>
    <option value="flower">花朵</option>
    <option value="star">星星</option>
    <option value="firework">烟花</option>
    <option value="deathlyHallows">死亡圣器</option>
    <option value="lightningScar">闪电疤痕</option>
  </select>

  <input type="color" id="colorPicker" value="#FFD700">
</div>

<button id="fullscreenBtn">全屏</button>

<div id="tip">
    双手拇指与食指：靠近 → 收缩 ｜ 分开 → 扩散
    <span>双手掌心：靠近 → 斥力 (怪奇物语能量冲击) ｜ 分开 → 引力 (怪奇物语能量场)</span>
    <span>单手张开并移动：施展咒语 (哈利·波特魔法火花)</span>
</div>

<div id="spellText"></div> <video id="video" autoplay playsinline muted></video>

<audio id="spellSound" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" preload="auto"></audio> 
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script>
  let scene = new THREE.Scene();
  let camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
  let renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  camera.position.z = 80;

  let particles, geometry, material;
  let particlePositions; // 存储粒子的原始位置
  let targetScale = 1;
  let particleColor = new THREE.Color(document.getElementById("colorPicker").value);
  let originalParticleColor = particleColor.clone(); // 存储原始颜色

  let handCenters = []; // 存储两只手的 3D 位置
  let forceFactor = 0.05; // 力的强度
  let repulsionThreshold = 30; // 产生斥力的距离阈值 (场景空间)

  // 施法特效相关
  let spellParticles = [];
  let spellParticleMaterial;
  let lastHandPosition = new THREE.Vector3(); // 用于检测手部移动
  let isCastingSpell = false;
  let spellCooldown = 0;
  const SPELL_COOLDOWN_TIME = 120; // 冷却时间帧数

  // 咒语列表
  const spells = [
    "Expelliarmus! (除你武器！)",
    "Lumos! (荧光闪烁！)",
    "Alohomora! (阿拉霍洞开！)",
    "Wingardium Leviosa! (羽加迪姆 勒维奥萨！)",
    "Expecto Patronum! (呼神护卫！)",
    "Avada Kedavra! (阿瓦达索命！ - 仅供效果展示，请勿误用)"
  ];
  const spellSound = document.getElementById('spellSound');


  // 粒子形状生成函数 (与之前相同，略)
  function generateShapePositions(shapeName, count, scale = 1) {
    let positions = [];
    switch (shapeName) {
      case 'heart':
        for (let i = 0; i < count; i++) {
          let t = Math.random() * 2 * Math.PI;
          let x = 16 * Math.pow(Math.sin(t), 3) * scale;
          let y = (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) * scale;
          positions.push(x, y, (Math.random() - 0.5) * 5);
        }
        break;
      case 'flower':
        for (let i = 0; i < count; i++) {
          let t = Math.random() * 2 * Math.PI;
          let r = 20 * (1 + 0.8 * Math.sin(6 * t)) * scale;
          let x = r * Math.cos(t);
          let y = r * Math.sin(t);
          positions.push(x, y, (Math.random() - 0.5) * 5);
        }
        break;
      case 'star':
        for (let i = 0; i < count; i++) {
          let t = Math.random() * 2 * Math.PI;
          let r = (20 + Math.random() * 10) * scale;
          let x = r * Math.cos(t);
          let y = r * Math.sin(t);
          positions.push(x, y, (Math.random() - 0.5) * 5);
        }
        break;
      case 'firework':
        for (let i = 0; i < count; i++) {
          let x = (Math.random() - 0.5) * 60;
          let y = (Math.random() - 0.5) * 60;
          let z = (Math.random() - 0.5) * 60;
          positions.push(x, y, z);
        }
        break;
      case 'deathlyHallows':
        for (let i = 0; i < count; i++) {
          let x, y, z;
          if (Math.random() < 0.3) {
            let a = Math.random();
            let b = Math.random();
            if (a + b > 1) { a = 1 - a; b = 1 - b; }
            x = (a * (-20) + b * 20 + (1 - a - b) * 0) * scale;
            y = (a * (-15) + b * (-15) + (1 - a - b) * 15) * scale;
          } else if (Math.random() < 0.6) {
            let angle = Math.random() * 2 * Math.PI;
            x = Math.cos(angle) * 8 * scale;
            y = Math.sin(angle) * 8 * scale - 5 * scale;
          } else {
            x = 0;
            y = (Math.random() - 0.5) * 20 * scale;
          }
          z = (Math.random() - 0.5) * 2 * scale;
          positions.push(x, y, z);
        }
        break;
      case 'lightningScar':
        for (let i = 0; i < count; i++) {
          let p = Math.random();
          let x, y;
          if (p < 0.33) {
            x = THREE.MathUtils.lerp(-10, 0, p * 3) * scale;
            y = THREE.MathUtils.lerp(0, 10, p * 3) * scale;
          } else if (p < 0.66) {
            p = (p - 0.33) * 3;
            x = THREE.MathUtils.lerp(0, 10, p) * scale;
            y = THREE.MathUtils.lerp(10, -10, p) * scale;
          } else {
            p = (p - 0.66) * 3;
            x = THREE.MathUtils.lerp(10, 20, p) * scale;
            y = THREE.MathUtils.lerp(-10, 0, p) * scale;
          }
          positions.push(x, y, (Math.random() - 0.5) * 2 * scale);
        }
        break;
      case 'default':
      default:
        for (let i = 0; i < count; i++) {
          positions.push(
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50
          );
        }
        break;
    }
    return positions;
  }

  function createParticles(shapeName, color) {
    if (particles) scene.remove(particles);

    geometry = new THREE.BufferGeometry();
    const count = 2000;
    particlePositions = new Float32Array(generateShapePositions(shapeName, count, 0.8)); // 存储原始位置
    let currentPositions = new Float32Array(particlePositions); // 当前渲染位置

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(currentPositions, 3));
    
    material = new THREE.PointsMaterial({
      color: color,
      size: 0.8,
      transparent: true,
      opacity: 0.9,
      blending: THREE.AdditiveBlending
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);
    particleColor.set(color); // 更新粒子颜色变量
    originalParticleColor.set(color); // 更新原始颜色
  }

  createParticles(document.getElementById("shapeSelect").value, document.getElementById("colorPicker").value);

  // 创建施法火花粒子
  spellParticleMaterial = new THREE.PointsMaterial({
      color: 0xFFF0B0, // 魔法火花颜色 (淡黄色)
      size: 1.5,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending,
      depthWrite: false // 不写入深度缓冲区，防止遮挡
  });

  function createSpellParticles(position) {
      const spellGeometry = new THREE.BufferGeometry();
      const spellPositions = [];
      const spellLifetimes = [];
      const numSpellParticles = 50;

      for (let i = 0; i < numSpellParticles; i++) {
          // 在手部位置附近随机生成
          spellPositions.push(
              position.x + (Math.random() - 0.5) * 5,
              position.y + (Math.random() - 0.5) * 5,
              position.z + (Math.random() - 0.5) * 5
          );
          spellLifetimes.push(Math.random() * 60 + 30); // 30-90 帧生命周期
      }
      spellGeometry.setAttribute('position', new THREE.Float32BufferAttribute(spellPositions, 3));
      spellGeometry.setAttribute('lifetime', new THREE.Float32BufferAttribute(spellLifetimes, 1)); // 存储生命周期

      const newSpellParticles = new THREE.Points(spellGeometry, spellParticleMaterial.clone());
      newSpellParticles.name = 'spellEffect'; // 方便识别和移除
      scene.add(newSpellParticles);
      spellParticles.push(newSpellParticles);
  }


  // 动画循环
  function animate() {
    requestAnimationFrame(animate);

    if (spellCooldown > 0) {
        spellCooldown--;
    }

    if (particles && particlePositions && handCenters.length > 0) {
      let currentPositions = geometry.attributes.position.array;
      let tempVector = new THREE.Vector3();

      for (let i = 0; i < particlePositions.length; i += 3) {
        tempVector.set(currentPositions[i], currentPositions[i+1], currentPositions[i+2]);
        
        handCenters.forEach(handCenter => {
          let dx = tempVector.x - handCenter.x;
          let dy = tempVector.y - handCenter.y;
          let dz = tempVector.z - handCenter.z;
          let distSq = dx*dx + dy*dy + dz*dz;
          let dist = Math.sqrt(distSq);

          if (dist > 0) {
            dx /= dist; dy /= dist; dz /= dist;
          } else { 
            dx = Math.random() - 0.5; dy = Math.random() - 0.5; dz = Math.random() - 0.5;
            let len = Math.sqrt(dx*dx+dy*dy+dz*dz);
            dx /= len; dy /= len; dz /= len;
          }
          
          let forceStrength = 0;
          // 引力/斥力逻辑 (怪奇物语)
          if (handCenters.length > 1) { // 只有两只手时才计算引力/斥力
              if (handCenter.distToOtherHand < repulsionThreshold) { // 两手靠近，斥力
                  forceStrength = forceFactor * 10 / (distSq + 1); 
              } else { // 两手分开，引力
                  forceStrength = -forceFactor * 5 / (distSq + 1); 
              }
          } else { // 单手时，仍然可以有微弱的引力
             forceStrength = -forceFactor * 0.5 / (distSq + 1); 
          }
          
          currentPositions[i] += dx * forceStrength;
          currentPositions[i+1] += dy * forceStrength;
          currentPositions[i+2] += dz * forceStrength;
        });

        // 逐渐返回原始形状 (哈利波特魔法粒子)
        currentPositions[i] += (particlePositions[i] - currentPositions[i]) * 0.01;
        currentPositions[i+1] += (particlePositions[i+1] - currentPositions[i+1]) * 0.01;
        currentPositions[i+2] += (particlePositions[i+2] - currentPositions[i+2]) * 0.01;
      }
      geometry.attributes.position.needsUpdate = true;
    }


    // 施法火花粒子更新 (哈利波特)
    for (let i = spellParticles.length - 1; i >= 0; i--) {
        const sp = spellParticles[i];
        const lifetimes = sp.geometry.attributes.lifetime.array;
        const positions = sp.geometry.attributes.position.array;
        const opacities = sp.material.opacity;

        let allDead = true;
        for (let j = 0; j < lifetimes.length; j++) {
            lifetimes[j]--;
            if (lifetimes[j] > 0) {
                allDead = false;
                // 粒子向上漂浮并扩散
                positions[j*3+1] += 0.2; // Y轴向上
                positions[j*3] += (Math.random() - 0.5) * 0.5; // 随机X
                positions[j*3+2] += (Math.random() - 0.5) * 0.5; // 随机Z
            } else {
                // 将死去的粒子移到很远的地方，或者直接设置为透明
                positions[j*3] = positions[j*3+1] = positions[j*3+2] = 10000; 
            }
        }
        sp.geometry.attributes.position.needsUpdate = true;
        
        if (allDead) {
            scene.remove(sp);
            spellParticles.splice(i, 1);
        } else {
            sp.material.opacity = Math.max(0, opacities * 0.95 - 0.01); // 逐渐变淡
        }
    }


    if (particles) {
      particles.rotation.y += 0.002;
      particles.scale.setScalar(targetScale);

      // 怪奇物语：根据双手距离调整颜色和闪烁感
      if (handCenters.length === 2) {
          let distBetweenHands = handCenters[0].distanceTo(handCenters[1]);
          if (distBetweenHands < repulsionThreshold * 2) { // 如果双手较近
              let mixFactor = 1 - (distBetweenHands / (repulsionThreshold * 2));
              material.color.lerpColors(originalParticleColor, new THREE.Color(0xAA0000), mixFactor * 0.7); // 变红更明显
              material.opacity = 0.8 + Math.sin(performance.now() * 0.1) * 0.15; // 闪烁更明显
          } else {
              material.color.copy(originalParticleColor);
              material.opacity = 0.9;
          }
      } else {
          material.color.copy(originalParticleColor);
          material.opacity = 0.9;
      }
    }
    renderer.render(scene, camera);
  }

  animate();

  window.onresize = () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  };

  document.getElementById("fullscreenBtn").onclick = () => {
    if (!document.fullscreenElement) {
      document.body.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  };

  document.getElementById("colorPicker").oninput = e => {
    material.color.set(e.target.value);
    originalParticleColor.set(e.target.value);
  };
  
  document.getElementById("shapeSelect").onchange = e => {
    createParticles(e.target.value, document.getElementById("colorPicker").value);
  };

  // ===== MediaPipe 手势识别 =====
  const video = document.getElementById('video');
  const spellTextElement = document.getElementById('spellText');

  const hands = new Hands({
    locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });

  hands.setOptions({
    maxNumHands: 2,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6
  });

  hands.onResults(results => {
    handCenters = []; 
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
      // 粒子缩放控制 (第一个手的食指与拇指距离)
      let p1 = results.multiHandLandmarks[0][4]; 
      let p2 = results.multiHandLandmarks[0][8]; 
      let dx = p1.x - p2.x;
      let dy = p1.y - p2.y;
      let dist = Math.sqrt(dx * dx + dy * dy);
      targetScale = THREE.MathUtils.clamp(dist * 5, 0.3, 3);

      // 双手引力/斥力 & 施法检测
      results.multiHandLandmarks.forEach((handLandmarks, index) => {
        let middleFingerBase = handLandmarks[9]; // 中指根部作为手掌中心
        let wrist = handLandmarks[0];

        // 转换到 3D 场景坐标
        let x = (middleFingerBase.x - 0.5) * window.innerWidth / 10;
        let y = -(middleFingerBase.y - 0.5) * window.innerHeight / 10;
        let z = (middleFingerBase.z * 100 - 50) * 0.5; 
        let handCenter3D = new THREE.Vector3(x, y, z);

        // 如果有多只手，计算它们之间的距离
        if (results.multiHandLandmarks.length > 1) {
            let otherHandIndex = index === 0 ? 1 : 0;
            let otherHandBase = results.multiHandLandmarks[otherHandIndex][9];
            let otherHandX = (otherHandBase.x - 0.5) * window.innerWidth / 10;
            let otherHandY = -(otherHandBase.y - 0.5) * window.innerHeight / 10;
            let otherHandZ = (otherHandBase.z * 100 - 50) * 0.5;
            let otherHandCenter3D = new THREE.Vector3(otherHandX, otherHandY, otherHandZ);
            handCenter3D.distToOtherHand = handCenter3D.distanceTo(otherHandCenter3D);
        }
        
        handCenters.push(handCenter3D);

        // --- 哈利·波特施法检测 ---
        // 检测手掌是否张开 (通过食指和无名指是否伸直)
        const thumbTip = handLandmarks[4];
        const indexTip = handLandmarks[8];
        const middleTip = handLandmarks[12];
        const ringTip = handLandmarks[16];
        const pinkyTip = handLandmarks[20];
        const wristPoint = handLandmarks[0];

        // 简单判断：拇指、食指、中指、无名指、小指尖都远离手腕，且彼此距离适当
        // 这需要更复杂的逻辑，这里简化为：指尖Y坐标高于手腕Y坐标一定程度
        const isHandOpen = 
            indexTip.y < wristPoint.y * 0.8 && // 食指高于手腕
            middleTip.y < wristPoint.y * 0.8 && // 中指高于手腕
            ringTip.y < wristPoint.y * 0.8 && // 无名指高于手腕
            pinkyTip.y < wristPoint.y * 0.8 && // 小指高于手腕
            thumbTip.x < wristPoint.x + 0.1 && // 拇指远离掌心 (根据左右手调整)
            dist > 0.1; // 拇指食指有一定距离

        // 检测手部移动速度（用于“挥舞”效果）
        let currentHandPosition = new THREE.Vector3(x, y, z);
        let handSpeed = currentHandPosition.distanceTo(lastHandPosition);
        lastHandPosition.copy(currentHandPosition);

        // 如果手掌张开且有较快移动，并且不在冷却中
        if (isHandOpen && handSpeed > 3 && spellCooldown <= 0) { // handSpeed阈值可能需要调整
            isCastingSpell = true;
            spellCooldown = SPELL_COOLDOWN_TIME; // 进入冷却
            castSpell(handCenter3D);
        } else {
            isCastingSpell = false;
        }

      });
    }
  });

  // 施法函数
  function castSpell(handPosition) {
    if (spellSound) {
        spellSound.currentTime = 0; // 从头播放
        spellSound.play().catch(e => console.log("Spell sound failed to play:", e)); // 捕获自动播放错误
    }
    createSpellParticles(handPosition); // 在手部位置生成魔法火花

    // 显示随机咒语
    const randomSpell = spells[Math.floor(Math.random() * spells.length)];
    spellTextElement.textContent = randomSpell;
    spellTextElement.classList.add('spell-active');
    setTimeout(() => {
        spellTextElement.classList.remove('spell-active');
    }, 1500); // 1.5秒后消失
  }


  // 手动发送视频帧到 MediaPipe
  async function sendFrameToHands() {
    if (video.readyState >= 2) { 
      await hands.send({ image: video });
    }
    requestAnimationFrame(sendFrameToHands);
  }

  // 替换后的启动逻辑
  document.getElementById("startBtn").onclick = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: 'user', 
          width: 640,
          height: 480
        }
      });
      
      video.srcObject = stream;
      
      video.onloadeddata = () => {
          video.play();
          document.getElementById("startBtn").style.display = "none";
          sendFrameToHands(); 
      };
      
    } catch (e) {
      alert("摄像头启动失败！请检查系统权限或重启浏览器。\n错误信息：" + e.message + 
            "\n提示：确保摄像头未被其他应用占用，且浏览器拥有摄像头权限。");
    }
  };
</script>

</body>
</html>
